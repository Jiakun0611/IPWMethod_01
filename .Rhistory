library(devtools)
document()   # Generates man/ + NAMESPACE from roxygen comments
library(roxygen2)
unlink("NAMESPACE")  # delete NAMESPACE as roxygen2 will generate new one
usethis::use_r("IPWM")
devtools::document()
unlink("NAMESPACE")  # delete NAMESPACE as roxygen2 will generate new one
usethis::use_r("IPWM")
#'   p_formula = list(~ x1 + x2, ~ x3 * x4),
#'   cali = TRUE
#' )
#' }
#'
#' @seealso
#' \code{\link{IPWM_One}}, \code{\link{IPWM_Multi_Raking}},
#' \code{\link{process_p_formula}}
#'
#' @export
IPWM <- function(
sc,                          # sc: convenience sample data.frame
sp,                          # sp: data.frame (One) or list of data.frames (Multi)
y,                           # y: outcome variable in sc
weight,                      # weight: string (One) or vector (Multi)
p_formula = NULL,            # p_formula: formula (One) or list of formulas (Multi)
method = NULL,               # method: one of "ALP", "CLW", "raking" (auto "multi" for list-type sp)
zcol = NULL,                 # zcol: domain variable for subset calculation
cali = TRUE,                 # cali: whether to run pairwise pre-calibration (Multi only)
maxit = 20,                  # maxit: maximum Newton–Raphson iterations
tol = 1e-4,                  # tol: convergence tolerance for Newton–Raphson
verbose = FALSE              # verbose: print intermediate updates
) {
# --- 0) Detect single vs. multiple reference samples ---
if (is.list(sp) && !is.data.frame(sp) && all(vapply(sp, is.data.frame, logical(1)))) {
# Multi-reference case
if (is.null(method)) method <- "multi"
if (method != "multi") {
warning("For list-type 'sp', method forcibly set to 'multi'.")
method <- "multi"
}
} else if (is.data.frame(sp)) {
# One-reference case
if (is.null(method)) {
stop("Please specify method = 'ALP', 'CLW', or 'raking' for one-reference case.")
}
} else {
stop("Argument 'sp' must be either a data.frame (one reference) or a list of data.frames (multi reference).")
}
# --- 0.5) Check and preprocess p_formula ---
p_vars <- NULL
if (!is.null(p_formula)) {
# If p_formula is a formula (or list of formulas) → preprocess
if (inherits(p_formula, "formula") ||
(is.list(p_formula) && all(vapply(p_formula, inherits, logical(1), "formula")))) {
processed <- process_p_formula(sc, sp, weight, y, zcol, p_formula)
sc     <- processed$sc
sp     <- processed$sp
p_vars <- processed$vars   # expanded variable names
} else {
# Otherwise, assume p_formula is already variable names → skip processing
p_vars <- p_formula
}
}
# --- 1) Run one-reference IPW method ---
if (method %in% c("ALP", "CLW", "raking")) {
result <- IPWM_One(
sc      = sc,
sp      = sp,
y       = y,
vars    = p_vars,
weight  = weight,
method  = method,
zcol    = zcol,
maxit   = maxit,
tol     = tol
)
}
# --- 2) Run multi-reference Raking method ---
else if (method == "multi") {
result <- IPWM_Multi_Raking(
sc       = sc,
sp       = sp,
y        = y,
vars     = p_vars,
weight   = weight,
cali     = cali,
zcol     = zcol,
maxit    = maxit,
tol      = tol,
verbose  = verbose
)
result$method <- "multi"
}
# --- 3) Invalid method ---
else {
stop("Unsupported method. Must be one of 'ALP', 'CLW', 'raking', or 'multi'.")
}
# --- 4) Return unified result object ---
class(result) <- "IPWM"
result$call <- match.call()
return(result)
}
devtools::document()
devtools::document()
unlink("NAMESPACE")  # delete NAMESPACE as roxygen2 will generate new one
usethis::use_r("IPWM")
devtools::document()
unlink("NAMESPACE")  # delete NAMESPACE as roxygen2 will generate new one
usethis::use_r("IPWM")
devtools::document()
build()      # Builds .tar.gz
install()    # Installs locally
library(IPWM)
library(IPWMethod)
?IPWM
# -------- Setting Up ------------
options(scipen = 999) #avoid sci expression
set.seed(123456)
N=500000
v1 = rbinom(N, size=1, prob=0.5)                # Bernoulli(0.5)
v2 = runif(N, min=0, max=2)                     # Uniform(0, 2)
v3 = rexp(N, rate = 1)                          # Exponential(1)
v4 = rchisq(N, df = 4)                          # Chi-square with 4 degrees of freedom
# Covariates
x1 = v1
x2 = v2 #+ 0.3 * x1
x3 = v3 #+ 0.2 * (x1 + x2)
x4 = v4 #+ 0.1 *(x1 + x2 + x3)
mu =  - x1 -  x2 + x3 + x4
y = mu + rnorm(N)
mu_true = mean(y)
np=12500
a <- x3 + 0.03*y
rng <- range(a)
if (diff(rng) == 0) stop("x3 + 0.03*y is constant; no solution (ratio is always 1).")
amin <- rng[1]; amax <- rng[2]
cnst_sp <- (amax - 20*amin) / 19
# sanity check
q <- cnst_sp + a
(max(q) / min(q))  # should be 20
pi_p1=np * q / sum(q)  #inclusion probability for fp
max(pi_p1)/min(pi_p1)   # 20
# pi_p are all valid
any(is.na(pi_p1))        #False
all(pi_p1>0 & pi_p1<1)    #True
di1=1/pi_p1
np=25000
a <- x3 + 0.03*y
rng <- range(a)
if (diff(rng) == 0) stop("x3 + 0.03*y is constant; no solution (ratio is always 1).")
amin <- rng[1]; amax <- rng[2]
cnst_sp <- (amax - 20*amin) / 19
# sanity check
q <- cnst_sp + a
(max(q) / min(q))  # should be 20
pi_p2=np * q / sum(q)  #inclusion probability for fp
max(pi_p2)/min(pi_p2)   # 20
# pi_p2 are all valid
any(is.na(pi_p2))        #False
all(pi_p2>0 & pi_p2<1)    #True
di2=1/pi_p2
fp = data.frame( x1 = x1, x2 = x2, x3 = x3, x4 = x4 , y = y, wt_sp1=di1, wt_sp2=di2 )
nc = 2500
eta <-  0.18 * x1 + 0.18 * x2 - 0.27 * x3 - 0.27 * x4
exp_beta0 = nc/(sum(exp(eta)))
beta0=log(exp_beta0)
# verify       sum(exp(eta+beta0))    #30000
pi_c  =  exp(eta+beta0)
all(pi_c>0 & pi_c<1)
fp$wt_sc=1/pi_c
# --- numeric datasets --- #
sc   = fp[rbinom(N, size = 1, pi_c) == 1,c('x1','x2','x3','x4','y')]
sp   = fp[rbinom(N, 1, pi_p1) == 1,c('x1','x2','x3','x4', 'wt_sp1')]
sp1  = fp[rbinom(N, 1, pi_p1) == 1,c('x1','x2', 'wt_sp1')]
sp2  = fp[rbinom(N, 1, pi_p2) == 1,c('x3','x4', 'wt_sp2')]
sp3  = fp[rbinom(N, 1, pi_p1) == 1,c('x1','x2','x3', 'wt_sp1')]
sp4  = fp[rbinom(N, 1, pi_p2) == 1,c('x3','x4','x2', 'wt_sp2')]
# --- categorical datasets --- #
# For sc
x3_factor <- factor(cut(sc$x3,
breaks = quantile(sc$x3, probs = seq(0, 1, by = 0.25), na.rm = TRUE),
include.lowest = TRUE,
labels = FALSE))
x4_factor <- factor(cut(sc$x4,
breaks = quantile(sc$x4, probs = seq(0, 1, by = 0.25), na.rm = TRUE),
include.lowest = TRUE,
labels = FALSE))
sc_cate <- data.frame(
x1 = sc$x1,
x2 = sc$x2,
x3 = x3_factor,
x4 = x4_factor,
y  = sc$y
)
# For sp
x3_factor <- factor(cut(sp$x3,
breaks = quantile(sp$x3, probs = seq(0, 1, by = 0.25), na.rm = TRUE),
include.lowest = TRUE,
labels = FALSE))
x4_factor <- factor(cut(sp$x4,
breaks = quantile(sp$x4, probs = seq(0, 1, by = 0.25), na.rm = TRUE),
include.lowest = TRUE,
labels = FALSE))
sp_cate <- data.frame(
x1 = sp$x1,
x2 = sp$x2,
x3 = x3_factor,
x4 = x4_factor,
wt_sp = sp$wt_sp1
)
# multi-ref case
IPWM(sc=sc,sp=list(sp1,sp2),y='y', weight = c('wt_sp1','wt_sp2'), cali = T)
devtools::install_github("Jiakun0611/IPWMethod")
# multi-ref case
IPWM(sc=sc,sp=list(sp1,sp2),y='y', weight = c('wt_sp1','wt_sp2'), cali = T)
# numeric
IPWM(sc=sc,sp=sp,y='y',weight = 'wt_sp1',method = "ALP")
devtools::install_github("Jiakun0611/IPWMethod")
library(IPWMethod)
# numeric
IPWM(sc=sc,sp=sp,y='y',weight = 'wt_sp1',method = "ALP")
outcome = IPWM(sc=sc,sp=sp,y='y',weight = 'wt_sp1',method = "ALP")
load_all()   # Loads your package into current R session
rm(list = c("IPWM"))
?IPWM
outcome = IPWM(sc=sc,sp=sp,y='y',weight = 'wt_sp1',method = "ALP")
summary(outcome)
library(devtools)
library(usethis)
library(roxygen2)
unlink("NAMESPACE")  # delete NAMESPACE as roxygen2 will generate new one
usethis::use_r("IPWM")
devtools::document()
source("C:/Users/Kevin/OneDrive - University of Toronto/Summer_Job/Github_IWH/Package3/IPWMethod/R/Print.R")
source("C:/Users/Kevin/OneDrive - University of Toronto/Summer_Job/Github_IWH/Package3/IPWMethod/R/Summary.R")
devtools::document()
build()      # Builds .tar.gz
install()    # Installs locally
source("C:/Users/Kevin/OneDrive - University of Toronto/Summer_Job/Github_IWH/Package3/IPWMethod/R/Multi_Precalibrate.R")
devtools::document()
source("C:/Users/Kevin/OneDrive - University of Toronto/Summer_Job/Github_IWH/Package3/IPWMethod/R/Multi_Precalibrate.R")
devtools::document()
rm(list = "PRECALI")
unlink("NAMESPACE")  # delete NAMESPACE as roxygen2 will generate new one
devtools::document()
unlink("NAMESPACE")  # delete NAMESPACE as roxygen2 will generate new one
devtools::document()
source("C:/Users/Kevin/OneDrive - University of Toronto/Summer_Job/Github_IWH/Package3/IPWMethod/R/Multi_Precalibrate.R")
source("C:/Users/Kevin/OneDrive - University of Toronto/Summer_Job/Github_IWH/Package3/IPWMethod/R/Multi_Precalibrate.R")
unlink("NAMESPACE")  # delete NAMESPACE as roxygen2 will generate new one
devtools::document()
build()      # Builds .tar.gz
install()    # Installs locally
source("C:/Users/Kevin/OneDrive - University of Toronto/Summer_Job/Github_IWH/Package3/IPWMethod/R/Multi_Precalibrate.R")
unlink("NAMESPACE")  # delete NAMESPACE as roxygen2 will generate new one
devtools::document()
unlink("NAMESPACE")  # delete NAMESPACE as roxygen2 will generate new one
devtools::document()
remove.packages("IPWMethod")
devtools::document()
